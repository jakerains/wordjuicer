import { saveAs } from 'file-saver';
import { Document, Packer, Paragraph, TextRun } from 'docx';
import { jsPDF } from 'jspdf';
import JSZip from 'jszip';
import { TranscriptionResult } from '../types';
import { APP_VERSION } from './version';

interface Timestamp {
  time: number;
  text: string;
}

export type ExportTheme = 'professional' | 'tropical';

// Theme configurations
const THEMES = {
  professional: {
    colors: {
      primary: '#2A2A2A',
      secondary: '#4A4A4A',
      accent: '#0066CC',
      text: '#333333',
      lightText: '#666666',
      background: '#FFFFFF'
    },
    fonts: {
      title: 'helvetica',
      body: 'helvetica'
    }
  },
  tropical: {
    colors: {
      primary: '#A2AD1E',
      secondary: '#F96C57',
      accent: '#F98128',
      text: '#1A1A1A',
      lightText: '#4A4A4A',
      background: 'linear-gradient(135deg, #FFF5E6, #FFF)'
    },
    fonts: {
      title: 'helvetica',
      body: 'helvetica'
    }
  }
};

// Format timestamp for SRT format
function formatSRTTime(seconds: number): string {
  const pad = (num: number): string => num.toString().padStart(2, '0');
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);
  return `${pad(hours)}:${pad(minutes)}:${pad(secs)},${ms.toString().padStart(3, '0')}`;
}

// Export as TXT
export function exportTXT(transcription: string, timestamps: Timestamp[], filename: string): void {
  const content = timestamps
    .map(({ time, text }) => `[${new Date(time * 1000).toISOString().substr(11, 8)}] ${text}`)
    .join('\n\n');
  
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const exportName = filename.replace(/\.[^/.]+$/, '') + '.txt';
  saveAs(blob, exportName);
}

// Export as SRT
export function exportSRT(timestamps: Timestamp[], filename: string): void {
  const content = timestamps
    .map((item, index) => {
      const startTime = formatSRTTime(item.time);
      const endTime = formatSRTTime(item.time + 2); // Assuming 2-second duration per segment
      return `${index + 1}\n${startTime} --> ${endTime}\n${item.text}\n`;
    })
    .join('\n');
  
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const exportName = filename.replace(/\.[^/.]+$/, '') + '.srt';
  saveAs(blob, exportName);
}

// Export as DOCX
export async function exportDOCX(
  transcription: string,
  timestamps: Timestamp[],
  filename: string,
  theme: ExportTheme = 'professional'
): Promise<void> {
  const themeConfig = THEMES[theme];
  const currentDate = new Date().toLocaleDateString();

  const doc = new Document({
    styles: {
      paragraphStyles: [
        {
          id: 'title',
          name: 'Title',
          basedOn: 'Normal',
          next: 'Normal',
          quickFormat: true,
          run: {
            size: 32,
            bold: true,
            color: themeConfig.colors.text
          },
          paragraph: {
            spacing: { after: 300 }
          }
        },
        {
          id: 'subtitle',
          name: 'Subtitle',
          basedOn: 'Normal',
          next: 'Normal',
          quickFormat: true,
          run: {
            size: 24,
            color: themeConfig.colors.lightText
          },
          paragraph: {
            spacing: { after: 400 }
          }
        },
        {
          id: 'timestamp',
          name: 'Timestamp',
          basedOn: 'Normal',
          next: 'Normal',
          quickFormat: true,
          run: {
            size: 20,
            color: themeConfig.colors.primary
          },
          paragraph: {
            spacing: { after: 120 }
          }
        }
      ]
    },
    sections: [{
      properties: {},
      children: [
        new Paragraph({
          style: 'title',
          children: [
            new TextRun('Audio Transcription')
          ]
        }),
        new Paragraph({
          style: 'subtitle',
          children: [
            new TextRun(`Generated by Text Juicer ${APP_VERSION} on ${currentDate}`)
          ]
        }),
        ...timestamps.map(({ time, text }) => [
          new Paragraph({
            style: 'timestamp',
            children: [
              new TextRun(`[${new Date(time * 1000).toISOString().substr(11, 8)}]`)
            ]
          }),
          new Paragraph({
            style: 'Normal',
            spacing: { after: 300 },
            children: [
              new TextRun({
                text,
                size: 28,
                color: themeConfig.colors.text
              })
            ]
          })
        ]).flat()
      ]
    }]
  });

  const blob = await Packer.toBlob(doc);
  const exportName = filename.replace(/\.[^/.]+$/, '') + '.docx';
  saveAs(blob, exportName);
}

// Export as PDF
export function exportPDF(
  transcription: string,
  timestamps: Timestamp[],
  filename: string,
  theme: ExportTheme = 'professional'
): void {
  const themeConfig = THEMES[theme];
  const currentDate = new Date().toLocaleDateString();
  const pdf = new jsPDF();
  const lineHeight = 10;
  let yPosition = 30;
  const margins = { left: 20, right: 20, top: 30, bottom: 30 };
  // Set up document
  pdf.setFont('helvetica', 'bold');
  pdf.setFontSize(24);
  pdf.setTextColor(themeConfig.colors.text);
  pdf.text('Audio Transcription', 20, yPosition);
  yPosition += lineHeight * 2;

  // Add subtitle with date
  pdf.setFontSize(12);
  pdf.setFont('helvetica', 'normal');
  pdf.setTextColor(themeConfig.colors.lightText);
  pdf.text(`Generated on ${currentDate}`, 20, yPosition);
  yPosition += lineHeight * 3;

  // Add content
  pdf.setFontSize(11);
  pdf.setTextColor(themeConfig.colors.text);

  timestamps.forEach(({ time, text }) => {
    // Add timestamp
    pdf.setFont('helvetica', 'bold');
    pdf.setTextColor(themeConfig.colors.accent);
    const timestamp = `[${new Date(time * 1000).toISOString().substr(11, 8)}] `;
    pdf.text(timestamp, 20, yPosition);

    // Add text
    pdf.setFont('helvetica', 'normal');
    pdf.setTextColor(themeConfig.colors.text);
    const textLines = pdf.splitTextToSize(text, 170);
    pdf.text(textLines, 20, yPosition + lineHeight);

    yPosition += (textLines.length + 2) * lineHeight;

    // Add new page if needed
    if (yPosition > pdf.internal.pageSize.height - margins.bottom) {
      pdf.addPage();
      yPosition = 20;
    }
  });

  // Add page numbers and footer
  const pageCount = pdf.internal.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    pdf.setPage(i);
    pdf.setFontSize(10);
    pdf.setTextColor(themeConfig.colors.lightText);

    // Page numbers
    pdf.text(
      `Page ${i} of ${pageCount}`,
      pdf.internal.pageSize.width / 2,
      pdf.internal.pageSize.height - margins.bottom + 20,
      { align: 'center' }
    );
    
    // Custom footer with heart emoji
    pdf.setTextColor(themeConfig.colors.accent);
    pdf.text(
      'Transcribed with ðŸ’š from TextJuicer.app',
      pdf.internal.pageSize.width / 2,
      pdf.internal.pageSize.height - margins.bottom + 10,
      { align: 'center' }
    );
  }

  const exportName = filename.replace(/\.[^/.]+$/, '') + '.pdf';
  pdf.save(exportName);
}

// Export all transcriptions as a zip file
export async function exportAllTranscriptions(
  transcriptions: TranscriptionResult[], 
  theme: ExportTheme = 'professional'
): Promise<void> {
  const zip = new JSZip();
  
  for (const transcription of transcriptions) {
    const folderName = transcription.filename.replace(/\.[^/.]+$/, '');
    const folder = zip.folder(folderName);
    if (!folder) continue;

    // Add TXT version
    const txtContent = transcription.timestamps
      .map(({ time, text }) => `[${new Date(time * 1000).toISOString().substr(11, 8)}] ${text}`)
      .join('\n\n');
    folder.file(`${folderName}.txt`, txtContent);

    // Add SRT version
    const srtContent = transcription.timestamps
      .map((item, index) => {
        const startTime = formatSRTTime(item.time);
        const endTime = formatSRTTime(item.time + 2);
        return `${index + 1}\n${startTime} --> ${endTime}\n${item.text}\n`;
      })
      .join('\n');
    folder.file(`${folderName}.srt`, srtContent);

    try {
      // Create DOCX document
      const doc = new Document({
        sections: [{
          properties: {},
          children: [
            new Paragraph({
              children: [
                new TextRun({
                  text: 'Audio Transcription',
                  bold: true,
                  size: 32,
                }),
              ],
            }),
            new Paragraph({
              children: [new TextRun('')],
            }),
            ...transcription.timestamps.map(({ time, text }) => [
              new Paragraph({
                children: [
                  new TextRun({
                    text: `[${new Date(time * 1000).toISOString().substr(11, 8)}] `,
                    bold: true,
                    size: 24,
                  }),
                  new TextRun({
                    text,
                    size: 24,
                  }),
                ],
              })
            ]).flat()
          ],
        }],
      });

      const docxBlob = await Packer.toBlob(doc);
      const docxBuffer = await docxBlob.arrayBuffer();
      folder.file(`${folderName}.docx`, docxBuffer);
    } catch (error) {
      console.error(`Failed to create DOCX for ${folderName}:`, error);
    }

    try {
      // Create PDF document
      const pdf = new jsPDF();
      const lineHeight = 10;
      let yPosition = 20;

      pdf.setFontSize(20);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Audio Transcription', 20, yPosition);
      yPosition += lineHeight * 2;

      pdf.setFontSize(12);
      transcription.timestamps.forEach(({ time, text }) => {
        pdf.setFont('helvetica', 'bold');
        const timestamp = `[${new Date(time * 1000).toISOString().substr(11, 8)}]`;
        pdf.text(timestamp, 20, yPosition);

        pdf.setFont('helvetica', 'normal');
        const textLines = pdf.splitTextToSize(text, 170);
        pdf.text(textLines, 20, yPosition + lineHeight);

        yPosition += (textLines.length + 2) * lineHeight;

        if (yPosition > 270) {
          pdf.addPage();
          yPosition = 20;
        }
      });

      const pdfBlob = pdf.output('blob');
      const pdfBuffer = await pdfBlob.arrayBuffer();
      folder.file(`${folderName}.pdf`, pdfBuffer);
    } catch (error) {
      console.error(`Failed to create PDF for ${folderName}:`, error);
    }
  }

  // Generate and save the zip file
  const zipBlob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
  saveAs(zipBlob, `text-juicer-exports-${new Date().toISOString().split('T')[0]}.zip`);
}