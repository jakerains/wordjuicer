import { saveAs } from 'file-saver';
import { Document, Packer, Paragraph, TextRun } from 'docx';
import { jsPDF } from 'jspdf';
import JSZip from 'jszip';
import { TranscriptionResult } from '../types';
import { APP_VERSION } from './version';
import { formatTimestamp } from './formatters';

interface Timestamp {
  time: number;
  text: string;
}

export type ExportTheme = 'professional' | 'tropical';

// Theme configurations
const THEMES = {
  professional: {
    colors: {
      primary: '#2A2A2A',
      secondary: '#4A4A4A',
      accent: '#0066CC',
      text: '#333333',
      lightText: '#666666',
      background: '#FFFFFF'
    },
    fonts: {
      title: 'helvetica',
      body: 'helvetica'
    }
  },
  tropical: {
    colors: {
      primary: '#A2AD1E',
      secondary: '#F96C57',
      accent: '#F98128',
      text: '#1A1A1A',
      lightText: '#4A4A4A',
      background: 'linear-gradient(135deg, #FFF5E6, #FFF)'
    },
    fonts: {
      title: 'helvetica',
      body: 'helvetica'
    }
  }
};

// Format timestamp for SRT format
function formatSRTTime(seconds: number): string {
  const pad = (num: number): string => num.toString().padStart(2, '0');
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);
  const ms = Math.floor((seconds % 1) * 1000);
  return `${pad(hours)}:${pad(minutes)}:${pad(secs)},${ms.toString().padStart(3, '0')}`;
}

// Export as TXT
export function exportTXT(transcription: string, timestamps: Timestamp[], filename: string): void {
  const content = timestamps
    .map(({ time, text }) => `[${new Date(time * 1000).toISOString().substr(11, 8)}] ${text}`)
    .join('\n\n');
  
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const exportName = filename.replace(/\.[^/.]+$/, '') + '.txt';
  saveAs(blob, exportName);
}

// Export as SRT
export function exportSRT(timestamps: Timestamp[], filename: string): void {
  const content = timestamps
    .map((item, index) => {
      const startTime = formatSRTTime(item.time);
      const endTime = formatSRTTime(item.time + 2); // Assuming 2-second duration per segment
      return `${index + 1}\n${startTime} --> ${endTime}\n${item.text}\n`;
    })
    .join('\n');
  
  const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
  const exportName = filename.replace(/\.[^/.]+$/, '') + '.srt';
  saveAs(blob, exportName);
}

// Export as DOCX
export async function exportDOCX(
  transcription: string,
  timestamps: Timestamp[],
  filename: string,
  theme: ExportTheme = 'professional'
): Promise<void> {
  const themeConfig = THEMES[theme];
  const currentDate = new Date().toLocaleDateString();

  const doc = new Document({
    styles: {
      paragraphStyles: [
        {
          id: 'title',
          name: 'Title',
          basedOn: 'Normal',
          next: 'Normal',
          quickFormat: true,
          run: {
            size: 32,
            bold: true,
            color: themeConfig.colors.text
          },
          paragraph: {
            spacing: { after: 300 }
          }
        },
        {
          id: 'subtitle',
          name: 'Subtitle',
          basedOn: 'Normal',
          next: 'Normal',
          quickFormat: true,
          run: {
            size: 24,
            color: themeConfig.colors.lightText
          },
          paragraph: {
            spacing: { after: 400 }
          }
        },
        {
          id: 'timestamp',
          name: 'Timestamp',
          basedOn: 'Normal',
          next: 'Normal',
          quickFormat: true,
          run: {
            size: 20,
            color: themeConfig.colors.primary
          },
          paragraph: {
            spacing: { after: 120 }
          }
        }
      ]
    },
    sections: [{
      properties: {},
      children: [
        new Paragraph({
          style: 'title',
          children: [
            new TextRun('Audio Transcription')
          ]
        }),
        new Paragraph({
          style: 'subtitle',
          children: [
            new TextRun(`Generated by Word Juicer ${APP_VERSION} on ${currentDate}`)
          ]
        }),
        ...timestamps.map(({ time, text }) => [
          new Paragraph({
            style: 'timestamp',
            children: [
              new TextRun(`[${new Date(time * 1000).toISOString().substr(11, 8)}]`)
            ]
          }),
          new Paragraph({
            style: 'Normal',
            spacing: { after: 300 },
            children: [
              new TextRun({
                text,
                size: 28,
                color: themeConfig.colors.text
              })
            ]
          })
        ]).flat()
      ]
    }]
  });

  const blob = await Packer.toBlob(doc);
  const exportName = filename.replace(/\.[^/.]+$/, '') + '.docx';
  saveAs(blob, exportName);
}

// Helper function to add a styled header
function addStyledHeader(pdf: jsPDF, text: string, y: number) {
  pdf.setFont('helvetica', 'bold');
  pdf.setFontSize(24);
  pdf.setTextColor('#333333');
  pdf.text(text, 20, y);
  
  // Add an accent line under the header
  pdf.setDrawColor(249, 108, 87); // #F96C57
  pdf.setLineWidth(0.5);
  pdf.line(20, y + 2, 190, y + 2);
}

// Helper function to add styled timestamps
function addStyledTimestamp(pdf: jsPDF, time: number, text: string, y: number) {
  // Time bubble with gradient effect
  const timeText = formatTimestamp(time);
  const timeWidth = pdf.getTextWidth(timeText) + 12;
  
  // Add gradient-like effect for time bubble
  for (let i = 0; i < 3; i++) {
    pdf.setFillColor(
      162 - i * 10,  // Slightly darker variations of #A2AD1E
      173 - i * 10,
      30 - i * 2
    );
    pdf.roundedRect(20 + i * 0.3, y - 5 + i * 0.3, timeWidth - i * 0.6, 7 - i * 0.3, 2, 2, 'F');
  }
  
  // Time text with slight shadow effect
  pdf.setFont('helvetica', 'bold');
  pdf.setFontSize(9);
  pdf.setTextColor(40, 40, 40, 0.1);  // Shadow
  pdf.text(timeText, 26.2, y + 0.2);
  pdf.setTextColor(255, 255, 255);     // Actual text
  pdf.text(timeText, 26, y);
  
  // Transcript text with improved typography
  pdf.setTextColor(51, 51, 51);
  pdf.setFont('helvetica', 'normal');
  pdf.setFontSize(11);
  const lines = pdf.splitTextToSize(text, 145);  // Slightly narrower for better readability
  
  // Add a subtle background for the text
  const textHeight = lines.length * 6;
  pdf.setFillColor(249, 249, 250);
  pdf.roundedRect(20 + timeWidth + 5, y - 4, 150, textHeight + 6, 1, 1, 'F');
  
  // Add the text with proper line height
  lines.forEach((line: string, index: number) => {
    pdf.text(line, 20 + timeWidth + 8, y + (index * 6));
  });
  
  return textHeight;
}

// Helper function to add styled footer
function addStyledFooter(pdf: jsPDF) {
  const pageHeight = pdf.internal.pageSize.height;
  const pageWidth = pdf.internal.pageSize.width;
  
  // Simple footer text
  pdf.setFont('helvetica', 'normal');
  pdf.setFontSize(8);
  pdf.setTextColor(128, 128, 128);
  pdf.text(`Generated by Word Juicer ${APP_VERSION}`, pageWidth / 2, pageHeight - 10, { align: 'center' });
}

// Export as PDF
export function exportPDF(
  transcription: string,
  timestamps: Timestamp[],
  filename: string,
  theme: ExportTheme = 'professional'
): void {
  const themeConfig = THEMES[theme];
  const currentDate = new Date().toLocaleDateString();
  const pdf = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4'
  });

  // Set document properties
  pdf.setProperties({
    title: filename,
    subject: 'Audio Transcription',
    author: 'Word Juicer',
    keywords: 'transcription, audio, word juicer',
    creator: 'Word Juicer'
  });

  let y = 20;

  // Add header
  addStyledHeader(pdf, 'Transcription', y);
  y += 15;

  // Add metadata
  pdf.setFont('helvetica', 'normal');
  pdf.setFontSize(10);
  pdf.setTextColor(130, 130, 130);
  pdf.text(`File: ${filename}`, 20, y);
  pdf.text(`Date: ${currentDate}`, 20, y + 5);
  y += 15;

  // Add content
  timestamps.forEach(({ time, text }) => {
    if (y > 250) { // Check if we need a new page
      addStyledFooter(pdf);
      pdf.addPage();
      y = 20;
    }
    
    const textHeight = addStyledTimestamp(pdf, time, text, y);
    y += textHeight + 8;
  });

  // Add footer to the last page
  addStyledFooter(pdf);

  // Save the PDF
  pdf.save(`${filename.replace(/\.[^/.]+$/, '')}.pdf`);
}

// Export all transcriptions as a zip file
export async function exportAllTranscriptions(
  transcriptions: TranscriptionResult[], 
  theme: ExportTheme = 'professional'
): Promise<void> {
  const zip = new JSZip();
  
  for (const transcription of transcriptions) {
    const folderName = transcription.filename.replace(/\.[^/.]+$/, '');
    const folder = zip.folder(folderName);
    if (!folder) continue;

    // Add TXT version
    const txtContent = transcription.timestamps
      .map(({ time, text }) => `[${new Date(time * 1000).toISOString().substr(11, 8)}] ${text}`)
      .join('\n\n');
    folder.file(`${folderName}.txt`, txtContent);

    // Add SRT version
    const srtContent = transcription.timestamps
      .map((item, index) => {
        const startTime = formatSRTTime(item.time);
        const endTime = formatSRTTime(item.time + 2);
        return `${index + 1}\n${startTime} --> ${endTime}\n${item.text}\n`;
      })
      .join('\n');
    folder.file(`${folderName}.srt`, srtContent);

    try {
      // Create DOCX document
      const doc = new Document({
        sections: [{
          properties: {},
          children: [
            new Paragraph({
              children: [
                new TextRun({
                  text: 'Audio Transcription',
                  bold: true,
                  size: 32,
                }),
              ],
            }),
            new Paragraph({
              children: [new TextRun('')],
            }),
            ...transcription.timestamps.map(({ time, text }) => [
              new Paragraph({
                children: [
                  new TextRun({
                    text: `[${new Date(time * 1000).toISOString().substr(11, 8)}] `,
                    bold: true,
                    size: 24,
                  }),
                  new TextRun({
                    text,
                    size: 24,
                  }),
                ],
              })
            ]).flat()
          ],
        }],
      });

      const docxBlob = await Packer.toBlob(doc);
      const docxBuffer = await docxBlob.arrayBuffer();
      folder.file(`${folderName}.docx`, docxBuffer);
    } catch (error) {
      console.error(`Failed to create DOCX for ${folderName}:`, error);
    }

    try {
      // Create PDF document
      const pdf = new jsPDF();
      const lineHeight = 10;
      let yPosition = 20;

      pdf.setFontSize(20);
      pdf.setFont('helvetica', 'bold');
      pdf.text('Audio Transcription', 20, yPosition);
      yPosition += lineHeight * 2;

      pdf.setFontSize(12);
      transcription.timestamps.forEach(({ time, text }) => {
        pdf.setFont('helvetica', 'bold');
        const timestamp = `[${new Date(time * 1000).toISOString().substr(11, 8)}]`;
        pdf.text(timestamp, 20, yPosition);

        pdf.setFont('helvetica', 'normal');
        const textLines = pdf.splitTextToSize(text, 170);
        pdf.text(textLines, 20, yPosition + lineHeight);

        yPosition += (textLines.length + 2) * lineHeight;

        if (yPosition > 270) {
          pdf.addPage();
          yPosition = 20;
        }
      });

      const pdfBlob = pdf.output('blob');
      const pdfBuffer = await pdfBlob.arrayBuffer();
      folder.file(`${folderName}.pdf`, pdfBuffer);
    } catch (error) {
      console.error(`Failed to create PDF for ${folderName}:`, error);
    }
  }

  // Generate and save the zip file
  const zipBlob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
  saveAs(zipBlob, `text-juicer-exports-${new Date().toISOString().split('T')[0]}.zip`);
}